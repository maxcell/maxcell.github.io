---
title: 'Notes - The Rust Programming Language Book'
date: '2020-06-16'
slug: 'rust-book'
tags: ['rust', 'learning']
---

This is just a running list of notes along the way as I read the Rust Programming
Language Book. It is helpful for me to write out my raw thoughts 

### Chapter 1

Documentation is local, offline avaibility. One can always get the documentation
directly with the terminal through `rustup doc`. It isn't just documentation but
also other pieces such as "Rust by Example".

Unlike other programming languages such as JavaScript or Ruby, Rust splits apart 
the idea of compilation and execution.

Macros are different than functions. Super important to understanding each of their roles
however not much detail into that yet.

We have a built-in dependency manager in Rust called `Cargo`. It also handles how to
build our projects. In Rust, dependencies are referred to as **_crates_**. These 
will be found within the `Cargo.toml` files. It is similar to how a `package.json`
works within Node. Similiar as well, Cargo generates `.lock` files as well.

Some common Cargo info to make note of:
  - `cargo build` - creates an executable from Cargo.toml
  - `./target/debug/<file_name>` - location of executable
  - `cargo run` - builds and executes
  - `cargo check` - checks for compilation
    - May be useful to run more often than build if checking validity
  - `cargo build --release` compiles with optimizations

### Chapter 2

This was a project chapter, so I am writing down a lot of my internal
interpretations of the lines and coupling it with things that may be
explicitly written to make sure I have a good understanding.

#### Breaking down the project

```rust
use std::io;
```

To include libraries we will use the `use` keyword
and typically put them towards the top. `std::io` represents the standard 
library and we're pulling out a set of traits & functions(?) for input/output.

```rust
let mut bar = String::new();
```

- `let` is used for creating variables
- Variables are default to immutable, so we add `mut` to change them
- `associated function` (`::`) on the type and not an instance
  - sometimes called a static method
- `&` reference and by default are also immutable

`.expect("Failed to read line")`
- Is a way for us to handle failed `Result` types from io

`"You guessed: {}", guess`
- `{}` represents placeholders or string interpolation

`use rand::Rng` - Adds the `Rng` trait from rand
- `rand::thread_rng().gen_range(inclusive, exclusive)`

`cargo doc --open` - let's you figure out the methods, functions, and traits

`use std::cmp::Ordering` - an enum like `Result` from `.expect`

Shadowing a variable - converting a variable from one type to another is a common case

u32 - unsigned 32-bit integers

`loop` for infinite loops and `break` to break out

`match` looks for something like `Ok` or `Err`. Whatever the result looks like will determine how the call should handle it

### Chapter 3


#### Variables and Constants

Variables are immutable by default. In order to reassign the variables,
we have to declare them mutable and then we can.

Constants cannot be `mut`. They are always immutable. Must have its 
value type annotated. Must be an expression not a function or computed 
at runtime.

Shadowing - Declaring a new variable with the same name as the second.
It is different than marking something with `mut`. This allows us to
perform transformations on a value and then have the variable be 
immutable after those transformations have been completed. Also useful
for performing type transformations. We can't do this with replacing
with `mut`.

There are two data type subsets: scalar and compound
- Scalars are a single value. Composed of 4 primary types:
  1. integers (signed and unsigned)
  2. floating-point (IEEE-754)
  3. Booleans
  4. characters (emoji)
- Compound which group multiple values into one type. Composed of two:
  1. Tuples - fixed size length
    - Access positions with `.` and the index
  2. Array - every element must be the same type. Are fixed in size
    - If you want to grow your array, you should be using a vector

<Callout>

**What does this mean?**
> _"Arrays are useful when you want your data allocated on the stack rather than the heap"_

</Callout>

#### Functions

Prefer to have snake case and use `fn` keyword
Parameters must have the type declared
Assignments don't return values so no multiassigns

We can create blocks and the expressions can be evaluated

```rust
let y = {
  let x = 3;
  x + 1 // important not to have a semi-colon
};
```

Implicit returns must not have a semicolon

#### Control Flow

```rust playground=true
fn main(){
  let number = 3;

  if number < 5 {
    println!("condition was true");
  } else {
    println!("condition was false");
  }
}
```
The value in the `if` must be a Boolean

You can also use an `if` in a variable statement

```rust
let condition = true;
let number = if condition { 5 } else { 6 };
```

The types between the two cases must be same. Must have both if/else.

#### Repetition with Loops

- `loop`, `while`, `for`

To do a loop, just `loop` block!
we can return values in a look with a `break`

`while` are conditional based
`for` through a collection
`for element in a.iter()`

### Chapter 4 - Ownership

#### Ownership

Ownership relates to several unique features to Rust. Some ways we talk about it is borrowing, slices, and memory.

Rust is unique in the way that it allocates and frees memory, it uses an ownership model which is different C and different than JavaScript

- Stack -> LIFO (Last in First Out)
Stack contains fix, known data size
Anything else goes on a heap

pointers -> references to data (addresses)

> Think of being seated at a restaurant. When you enter, you state the number of people in your group, and the staff finds an empty table that fits everyone and leads you there. If someone in your group comes late, they can ask where you’ve been seated to find you.

Three Rules to Ownership:

- 1. Each value in Rust has a variable that’s called its owner.
- 2. There can only be one owner at a time.
- 3. When the owner goes out of scope, the value will be dropped.

`let s = "string"` - goes into the stack
`let mut s = String::from("hello");` 

```rust
// Does this automatically call drop
fn main() {
  let mut s = String::from("hello");
  s.push_str(", world");
}
```

Conceptually double reference is a shallow copy but also invalidates the first variable so it is known as a *move*

```rust
fn main() {
    let str1 = String::from("Jason");
    let mut str2 = str1;
    str2.push_str(", Chris");
    println!("The value of our string is: {}", str2);
}
```

```rust
fn main() {
    let str1 = String::from("Jason");
    let mut str2 = str1.clone();
    str2.push_str(", Chris");
    println!("The value of our first string: {}", str1);
    println!("The value of our second string: {}", str2);
}
```


What does this mean
> If a type has the Copy trait, an older variable is still usable after assignment. Rust won’t let us annotate a type with the Copy trait if the type, or any of its parts, has implemented the Drop trait.


Ownership code
```rust
fn main() {
    let s1 = String::from("hello");

    let (s2, len) = calculate_length(s1);

    println!("The length of '{}' is {}.", s2, len);
}

fn calculate_length(s: String) -> (String, usize) {
    let length = s.len(); // len() returns the length of a String

    (s, length)
}
```

#### Reference and borrowing

`&` reference operator
`*` deference operator

 A data race is similar to a race condition and happens when these three behaviors occur:

- Two or more pointers access the same data at the same time.
- At least one of the pointers is being used to write to the data.
- There’s no mechanism being used to synchronize access to the data.

### String Slices

A string slice is a reference to a part of a String. We will call a string
with a reference and the array bit, starting_index and end_index which is exclusive.

```rust
fn main() {
    let some_str = String::from("hello world");
    let hello = &some_str[0..5];
    let world = &some_str[6..11];
    println!("{}", hello); // hello
}
```

`..` is the range syntax. You can use one number and it will either be the
value to the end or the beginning to the value.

`&String` - represents a reference of a string
`&str` - represents a string slice

To do other slices you would just do `&[type]`

### Chapter 5 - Structs

In order to write a struct:
1) declare the struct and its fields
2) then to make an instance of it with the key/pairs
```rust
struct User {
    username: String,
    email: String,
    sign_in_count: u64,
    active: bool
}
```

Just like JavaScript we have field init shorthands, aka
you don't need to repeat the field name and variable name

Reminder yourself with what the difference between
these two data types are
```
expected struct `std::string::String`, found `&str`
```

This is the difference between string literals and dynamically
allocated strings. Remember that `&str` is also another name for
a string slice.

Remember the difference of borrowing. When we use a struct,
and we want to give the value back to the main function, remember to only borrow its value.

Associate functions are functions that don't take self within an implementation, basically like static functions.

Three types of structs
- Classic
- Tuple
- Unit

### Chapter 6 - Enums

Enums allow you to define a type by enumerating its
possible variants. It can encode meaning and data.
`Option` is a common/useful enum. Enums for Rust represent
_algebraic data types_ like in functional languages.

#### Defining an Enum

Similiar to a struct, we declare `enum`s with a name and
expose the different _variants_ that we'd like for it to have:

```rust
enum IpAddrKind {
  V4(String),
  V6(String)
}
```

These can take data in if we'd like, in addition we can also
write functions associated with them.

```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

impl Message {
    fn call(&self) {
        // method body would be defined here
    }
}

let m = Message::Write(String::from("hello"));
m.call();
```

`Option<T>` is another standard library enum that 
allows for us to expose two variants `Some<T>` or `None`.
It is a way to say that the option holds a piece of data 
of any type where as None is not a valid value. We want
to ensure that we verify that the data we have received is
valid.